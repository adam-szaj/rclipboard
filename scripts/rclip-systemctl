#!/usr/bin/env python3
"""
rclip-systemctl: manage rclipboard user-level systemd units for HTTP/HTTPS/UDS
listeners and proxy frontends.
"""

from __future__ import annotations

import argparse
import os
import shlex
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Optional, Tuple
from urllib.parse import urlparse

SYSTEMD_DIR = Path.home() / ".config" / "systemd" / "user"
ENV_FILE = Path.home() / ".config" / "rclipboard" / "env"
REPO_DIR = Path(__file__).resolve().parent.parent
UNIT_MARKER = "# Generated by rclip-systemctl"


class ConfigError(Exception):
    pass


@dataclass
class Endpoint:
    scheme: str
    host: Optional[str] = None
    port: Optional[int] = None
    uds_path: Optional[str] = None

    @property
    def is_https(self) -> bool:
        return self.scheme == "https"

    @property
    def is_http(self) -> bool:
        return self.scheme == "http"

    @property
    def is_uds(self) -> bool:
        return self.scheme == "uds"


@dataclass
class ServiceConfig:
    name: str
    bind: Endpoint
    proxy: bool = False
    upstream: Optional[Endpoint] = None
    ssl_keyfile: Optional[str] = None
    ssl_certfile: Optional[str] = None


def debug(msg: str) -> None:
    print(f"[rclip-systemctl] {msg}")


def parse_endpoint(raw: str, *, expect_port: bool = False) -> Endpoint:
    parsed = urlparse(raw)
    scheme = parsed.scheme
    if scheme not in {"http", "https", "uds"}:
        raise ConfigError(f"Unsupported scheme '{scheme}' in '{raw}'")
    if scheme == "uds":
        uds_path = parsed.path or parsed.netloc
        if not uds_path:
            raise ConfigError("UDS path is required (uds:///path/to.sock)")
        uds_path = os.path.expandvars(os.path.expanduser(uds_path))
        return Endpoint(scheme="uds", uds_path=uds_path)
    host = parsed.hostname or "127.0.0.1"
    port = parsed.port
    if expect_port and port is None:
        raise ConfigError(f"Port is required for {scheme} binding: {raw}")
    if port is None:
        port = 443 if scheme == "https" else 80
    return Endpoint(scheme=scheme, host=host, port=port)


def service_name(bind: Endpoint, proxy: bool) -> str:
    prefix = "rclipboard-proxy" if proxy else "rclipboard"
    return f"{prefix}-{bind.scheme}.service"


def render_exec(bind: Endpoint, ssl_keyfile: Optional[str],
                ssl_certfile: Optional[str]) -> str:
    cmd: List[str] = [sys.executable, "-m", "uvicorn", "app.main:app"]
    if bind.is_uds:
        cmd += ["--uds", bind.uds_path or ""]
    else:
        cmd += ["--host", bind.host or "127.0.0.1", "--port",
                str(bind.port or (443 if bind.is_https else 80))]
        if bind.is_https:
            if not ssl_keyfile or not ssl_certfile:
                raise ConfigError("HTTPS requires --ssl-keyfile and --ssl-certfile")
            cmd += ["--ssl-keyfile", ssl_keyfile, "--ssl-certfile", ssl_certfile]
    return " ".join(shlex.quote(part) for part in cmd)


def render_unit(cfg: ServiceConfig) -> str:
    exec_line = render_exec(cfg.bind, cfg.ssl_keyfile, cfg.ssl_certfile)
    env_lines: list[str] = []
    env_lines.append(f"EnvironmentFile=-{ENV_FILE}")
    env_lines.append("Environment=PYTHONUNBUFFERED=1")
    if cfg.proxy:
        env_lines.append("Environment=RCLIPBOARD_PROXY=1")
        if cfg.upstream:
            if cfg.upstream.is_uds:
                env_lines.append(f"Environment=RCLIPBOARD_PROXY_UDS={cfg.upstream.uds_path}")
            else:
                env_lines.append(f"Environment=RCLIPBOARD_PROXY_ADDR={cfg.upstream.host}")
                env_lines.append(f"Environment=RCLIPBOARD_PROXY_PORT={cfg.upstream.port}")
        else:
            raise ConfigError("--proxy requires --upstream")

    description_parts = ["rclipboard"]
    if cfg.proxy:
        description_parts.append("proxy")
    description_parts.append(cfg.bind.scheme.upper())
    description = " ".join(description_parts)
    env_block = "\n".join(env_lines)
    return f"""{UNIT_MARKER}
[Unit]
Description={description}
After=default.target

[Service]
Type=simple
{env_block}
WorkingDirectory={REPO_DIR}
ExecStart={exec_line}
Restart=on-failure
RestartSec=1s

[Install]
WantedBy=default.target
"""


def write_unit(cfg: ServiceConfig) -> Path:
    SYSTEMD_DIR.mkdir(parents=True, exist_ok=True)
    unit_path = SYSTEMD_DIR / cfg.name
    content = render_unit(cfg)
    unit_path.write_text(content)
    debug(f"Wrote {unit_path}")
    return unit_path


def is_generated_unit(path: Path) -> bool:
    try:
        with path.open() as f:
            first = f.readline()
            return UNIT_MARKER in first
    except FileNotFoundError:
        return False


def remove_unit_file(path: Path) -> None:
    if path.exists() and is_generated_unit(path):
        path.unlink()
        debug(f"Removed {path}")


def run_systemctl(args: Iterable[str], check: bool = True) -> subprocess.CompletedProcess:
    cmd = ["systemctl", "--user", *args]
    return subprocess.run(cmd, check=check)


def ensure_daemon_reload() -> None:
    run_systemctl(["daemon-reload"], check=True)


def choose_scheme(args: argparse.Namespace, bind: Optional[Endpoint]) -> str:
    scheme_flag = None
    if getattr(args, "http", False):
        scheme_flag = "http"
    if getattr(args, "https", False):
        scheme_flag = "https" if scheme_flag is None else scheme_flag
    if getattr(args, "uds", False):
        scheme_flag = "uds" if scheme_flag is None else scheme_flag
    if bind:
        if scheme_flag and scheme_flag != bind.scheme:
            raise ConfigError("Scheme mismatch between --bind and --http/--https/--uds")
        return bind.scheme
    if not scheme_flag:
        raise ConfigError("Specify --bind or one of --http/--https/--uds")
    return scheme_flag


def load_existing_unit(name: str) -> Path:
    unit_path = SYSTEMD_DIR / name
    if not unit_path.exists():
        raise ConfigError(f"{unit_path} does not exist; provide --bind to create it")
    return unit_path


def handle_enable(args: argparse.Namespace) -> None:
    bind = parse_endpoint(args.bind) if args.bind else None
    scheme = choose_scheme(args, bind)
    proxy = bool(args.proxy)
    if bind is None:
        # Only enable existing units
        name = service_name(Endpoint(scheme=scheme), proxy)
        load_existing_unit(name)
    else:
        if proxy:
            upstream = parse_endpoint(args.upstream) if args.upstream else None
        else:
            upstream = None
        name = service_name(bind, proxy)
        cfg = ServiceConfig(
            name=name,
            bind=bind,
            proxy=proxy,
            upstream=upstream,
            ssl_keyfile=args.ssl_keyfile,
            ssl_certfile=args.ssl_certfile,
        )
        write_unit(cfg)
    ensure_daemon_reload()
    run_systemctl(["enable", "--now", name], check=True)
    debug(f"Enabled and started {name}")


def handle_disable(args: argparse.Namespace) -> None:
    bind = parse_endpoint(args.bind) if args.bind else None
    scheme = choose_scheme(args, bind)
    proxy = bool(args.proxy)
    name = service_name(Endpoint(scheme=scheme), proxy)
    unit_path = SYSTEMD_DIR / name
    run_systemctl(["disable", "--now", name], check=False)
    remove_unit_file(unit_path)
    ensure_daemon_reload()
    debug(f"Disabled {name}")


def handle_simple_action(args: argparse.Namespace, action: str) -> None:
    bind = parse_endpoint(args.bind) if args.bind else None
    scheme = choose_scheme(args, bind)
    proxy = bool(args.proxy)
    name = service_name(Endpoint(scheme=scheme), proxy)
    load_existing_unit(name)
    run_systemctl([action, name], check=False)


def handle_status(args: argparse.Namespace) -> None:
    bind = parse_endpoint(args.bind) if args.bind else None
    scheme = choose_scheme(args, bind)
    proxy = bool(args.proxy)
    name = service_name(Endpoint(scheme=scheme), proxy)
    load_existing_unit(name)
    run_systemctl(["status", name], check=False)


def add_common_service_flags(sp: argparse.ArgumentParser) -> None:
    sp.add_argument("--bind", help="Bind URL (http://host:port, https://host:port, uds:///path)")
    sp.add_argument("--upstream", help="Upstream URL for proxy mode")
    sp.add_argument("--proxy", action="store_true", help="Enable proxy mode")
    sp.add_argument("--http", action="store_true", help="Target HTTP instance")
    sp.add_argument("--https", action="store_true", help="Target HTTPS instance")
    sp.add_argument("--uds", action="store_true", help="Target UDS instance")
    sp.add_argument("--ssl-keyfile", help="SSL key (HTTPS bind)")
    sp.add_argument("--ssl-certfile", help="SSL cert (HTTPS bind)")


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Manage rclipboard systemd --user units (http/https/uds, proxy or direct)."
    )
    subs = parser.add_subparsers(dest="command", required=True)

    enable = subs.add_parser("enable", help="Create/enable/start an instance")
    add_common_service_flags(enable)

    disable = subs.add_parser("disable", help="Disable/stop/remove an instance")
    add_common_service_flags(disable)

    start = subs.add_parser("start", help="Start an instance")
    add_common_service_flags(start)

    stop = subs.add_parser("stop", help="Stop an instance")
    add_common_service_flags(stop)

    restart = subs.add_parser("restart", help="Restart an instance")
    add_common_service_flags(restart)

    status = subs.add_parser("status", help="Show status for an instance")
    add_common_service_flags(status)

    return parser


def main(argv: Optional[List[str]] = None) -> None:
    parser = build_parser()
    args = parser.parse_args(argv)
    try:
        if args.command == "enable":
            handle_enable(args)
        elif args.command == "disable":
            handle_disable(args)
        elif args.command == "start":
            handle_simple_action(args, "start")
        elif args.command == "stop":
            handle_simple_action(args, "stop")
        elif args.command == "restart":
            handle_simple_action(args, "restart")
        elif args.command == "status":
            handle_status(args)
        else:
            parser.error(f"Unknown command {args.command}")
    except ConfigError as e:
        debug(f"Error: {e}")
        sys.exit(2)
    except subprocess.CalledProcessError as e:
        sys.exit(e.returncode)


if __name__ == "__main__":
    main()
